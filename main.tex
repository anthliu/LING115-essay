\documentclass[12pt]{article}

%
%Margin - 1 inch on all sides
%
\usepackage[letterpaper]{geometry}
\usepackage{times}
\usepackage{listings}
\usepackage{float}
\usepackage{csquotes}
\usepackage{subcaption}
\floatstyle{boxed} 
\restylefloat{figure}

\lstset
{ %Formatting for code in appendix
    basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}

\geometry{top=1.0in, bottom=1.0in, left=1.0in, right=1.0in}

%
%Doublespacing
%
\usepackage{setspace}
\doublespacing

%
%Rotating tables (e.g. sideways when too long)
%
\usepackage{rotating}


%
%Fancy-header package to modify header/page numbering (insert last name)
%
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{} 
\chead{} 
\rhead{Liu \thepage} 
\lfoot{} 
\cfoot{} 
\rfoot{} 
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt} 
%To make sure we actually have header 0.5in away from top edge
%12pt is one-sixth of an inch. Subtract this from 0.5in to get headsep value
\setlength\headsep{0.333in}

%
%Works cited environment
%(to start, use \begin{workscited...}, each entry preceded by \bibent)
% - from Ryan Alcock's MLA style file
%
\newcommand{\bibent}{\noindent \hangindent 40pt}
\newenvironment{workscited}{\newpage \begin{center} Works Cited \end{center}}{\newpage }


%
%Begin document
%
\begin{document}
\begin{flushleft}

%%%%First page name, class, etc
Anthony Liu\\
Professor Marlyse Baptista\\
LING 115\\
December 18 2017\\


%%%%Title
\begin{center}
Programming Languages and Natural Languages
\end{center}


%%%%Changes paragraph indentation to 0.5in
\setlength{\parindent}{0.5in}
%%%%Begin body of paper here

A programming language is a set of instructions that tell a computer
what actions to perform. Every application that runs on a computer
is written using a programming language.
%
If you've heard of
most popular languages used today, \textit{C, Java, Python}, etc, you may
wonder - Why don't we use natural languages such as English to
program? Surely programming in English is easier to learn and to teach
than a programming language?
%
In fact, using natural languages to create programs has been the goal
of many computer science researchers (Veres). However, the fact remains
that none of these efforts are truly using the ``full capacity" of
a natural language such as English in programming.

Consider an analogy of writing a list of instructions for baking
a cake. Though the instruction of \textit{1. Bake the cake.} may be humorous
in its lack of information, the instruction is an essentially correct
recipe of making a cake. The ambiguities of natural language
cause them to be unsuitable for programming.
%
Even the mundane \textit{x. Stir dry ingredients in bowl until mixed.}
is equally uninformative. Stir which ingredients?
What does it mean for ingredients to be mixed? How does one stir ingredients?
With a spoon? Stir clockwise? Of course, to the average cook, these questions are
irrelevant and can answered by common sense. However, when telling a
\textit{computer} to bake a cake, what does common sense mean? Does a
computer know what it means to stir ingredients?
%
By using natural language to write a recipe, we are left with
problems caused by ambiguities and a lack of precision.
Programming languages must be exact. The programmer and the computer
both agree on how a program should be executed.

\begin{figure}[h]
\centering
\caption{
``Guess the number game" in \textit{Python}.
In plain words, we can describe the execution of this
program line by line.
1. Set the \textit{answer} to be 42.
2. Let the user set the value of \textit{guess}.
3-4. While the value of \textit{guess} is not the same value
as the value of \textit{answer},
let the user set the value of \textit{guess} (the \textit{!=} word is an approximation
for the mathematical inequality symbol $\neq$.).
5. Finally, print (or display on the screen), ``You win!".
}
\begin{lstlisting}[language=Python]
answer = '42'
guess = input()
while guess != answer:
    guess = input()
print('You win!')
\end{lstlisting}
\label{fig:guess_number}
\end{figure}

Though natural language is unsuitable for direct use as a programming
language, its influence and usage in programming languages is undeniable.
In Figure \ref{fig:guess_number}, we show a simple ``Guess the number" game
in the programming language \textit{Python}.
The meaning of the program can be easily deciphered only using knowledge
of English and that most programming languages are evaluated line
by line from top to bottom.

The design and usage of Programming Languages is closely intertwined with spoken languages.
The similarities in the number guessing game in Figure \ref{fig:guess_number}
to its natural translation is no coincidence.
There are two reasons -
\begin{enumerate}
\item The general idea of programming languages is the same as natural
language - to put ideas into words. When a programming language needs
a word to describe an idea, that idea is often already encoded into
a word of natural language.
\item As alluded to earlier, a primary goal of programming language
designers and programmers is to have programming languages be both easy to
learn and understand. Like a large manuscript, the greatest applications
will have many subsections rewritten and modified when new features are
added or old features are broken. This need is amplified when large
teams must work on the same project, where programmers must read and
understand their respective programs to build upon it.
(As an example, as of 2014, the code
for Facebook has over 9.9 \textit{million} lines of code (Pearce).)

The most \textit{natural} way humans communicate is through natural
language. The incorporation of natural language into programming
increases the ease of understanding.
\end{enumerate}
There are two main ways natural language is incorporated into programming
- the design of the programming language and usage of the language, the
way programmer's ``speak" the language.

To speak of language design, we must revisit the problem of precision
written earlier, the difficulty of encoding our thoughts into the programs.
How do we tell a computer how to send our email?
How do we tell a computer how to display a photo on the screen?
A simple solution is to restrict our language only to \textit{simplest}
actions that a computer can do. Any application that is \textit{possible} to
create on a computer, is created by a limited set of instructions, or words.
Analogous, \textit{any} cooking recipe and technique can be described solely
by the activation and release of each muscle in the human body. The act
of stirring a bowl is carefully described from the usage of muscle groups
in the forearm, to the tightening of the fingers around the spoon.
Through this restriction, we sacrifice brevity and clarity for absolute
precision.
In the computer, these actions often include but are not limited to
adding numbers, saving numbers into registers, or memory locations,
and ``jumping", which can be used to repeat already executed code \footnotemark.

\begin{figure}[h]
\centering
\caption[Caption for LOF]{
Sample of the \textit{MIPS} ISA.
For example, when the computer reads the number 40, the computer will store
a value into its register, or memory. \footnotemark
}
\begin{tabular}{l l r}
Instruction & Mnemonic & Encoding \\
\hline
Load Byte & LB & 32 \\
Store Byte & SB & 40 \\
Add & ADD & 0 \\
\end{tabular}

\label{fig:MIPS_sample}
\end{figure}

These simple sets of instructions are called
\textit{Instruction Set Architectures}, or \textit{ISA}'s. Most ISA's will
contain less than 100 instructions. A sample of an ISA still used today is shown
in Figure \ref{fig:MIPS_sample}.

Although we have gained precision through this definition, there is
perhaps too much sacrifice in ease of use. Programming in these simple
languages, also known as assembly languages, is known to be difficult (Hyde).
Programming in assembly is tedious and error prone. Similar to writing
assemble is the futile
effort of trying to write a recipe using only muscle movements. Aside from
being impossible to read, writing a single incorrect muscle twitch can
result in a flying knife in the kitchen. \footnotemark

How do we both leverage the precision gained from using assembly
languages while making it easier to program? Just like natural languages,
programming languages can be translated from one another. Programmers
can use \textit{higher level languages}, languages more complex and 
easier to use, then translate their code into \textit{lower level languages},
such as assembly. With the power of this translation,
also known as compilation, language designers
have the power to define precise definitions of instructions, the
grammar and structure of their language, while being able to give
precise instructions to the computer. 
An example of code in a higher level
language, Python, is shown in Figure \ref{fig:guess_number}. When running
on a computer, this program is translated into a low level language, such
as MIPS.
This freedom allows designers to bring clarity and ease of use to
the language. By nature of natural language, the clearest meaning is
the one written in ``plain English". The use of natural language
in programming language design is most straightforward in the ``borrowing" of
natural language words in instructions. This ``borrowing" can often
restrict and expand their equivalent meanings in natural language.

\begin{figure}[h]
\centering
\caption[Caption for LOF]{If statements in programming languages.}
\begin{tabular}{l l}
    Language(s) & Format \\
\hline
    C-style languages (C/C++, Java, JavaScript) &
    \verb|if (...) { ... } else { ... }| \\
    Python & \verb|if ... :\n\t ... \n else: \n\t ...|
\end{tabular}

\label{fig:if_then}
\end{figure}

Words from natural language are constantly borrowed in the design of higher
level languages. A prime example of borrowings is English in the current
most popular languages. \verb|if (...) then (...) else (...)| statements,
are found in almost every programming language, see Figure \ref{fig:if_then}.
The concept of this conditional is universal in programming and language, that
most programming languages will ``borrow" the words if, then, and else to use
in the language. The most common words borrowed include
\verb| while, for, var (variable), class|, etc. \footnotemark

Despite the added power and flexibility higher level programming languages employ,
the words borrowed from natural language are greatly restricted in meaning. Consider
the following command ``Print ``Hello" to the screen if the value of $x$ is
10." An equivalent statement is ``If the value of $x$ is 10, print ``Hello"
to the screen.
The translation into the C language is \verb|if (x == 10) { printf("Hello"); }|.
In C, and in most programming languages, the location and relative ordering
of the \verb|if| is important. A misplaced \verb|if| at the back of the
\verb|printf| statement renders the program unable to run! In addition, every
punctuation, \verb|(), ;, {}|, is important to language, akin to natural
language grammar and punctuation.

Another curious case of language restriction comes from the usage of the English
word ``or". Similar to the usage of ``or" in mathematics, most languages
treat ``or" as a evaluation on true and false statements, and not as the
common usage as a choice. For example, the statement ``Would you like an
apple or an orange?" is not common usage in programming. The usage is more
akin to ``Are pigs falling from the sky, or am I crazy?".
In programming and mathematics, the whole statement is considered true
if \footnotemark \begin{enumerate}
    \item Pigs are falling from the sky and I'm not crazy
    \item Pigs are not falling from the sky but I'm crazy
    \item Pigs are falling from the sky and I'm crazy
\end{enumerate}

When words from natural language are used in programming languages, they
are often given new meaning instead of being restricted in the examples
given earlier. Perhaps the most infamous case (known for generally being
confusing to programming beginners) is the word \verb|static| in the
language C++ and many other languages that use this keyword. The keyword
is given a generally fixed definition of ``
pertaining to or characterized by a fixed or stationary condition.",
``showing little to no change",
or ``lacking movement, development, or vitality" (``static").
In C++, \verb|static| most pertains to the ``little to no change" definition,
though its usage is given breath to wholly two different meanings.
A \verb|static| variable is a variable that has a restricted lifetime, or
usage in the scope the variable is found. A \verb|static| member of a
class is a member that can be used without instantiating the a member of
the class (Stroustrup).

Equally influential on the content of programs as the designer of the programming language
is the writer of the program itself. Though language language designers
restrict the language definition to enable precise communication between
user and machine, it is ultimately the programmar that decides the final
words of the work. There are 2 main ways programmer's use ideas from
natural language in creating software - 1. Naming, 2. Commenting.

\begin{figure}
  \label{fig:naming_dem}
  \begin{subfigure}[b]{0.4\textwidth}
\begin{lstlisting}[language=Python]
i = 0
for j in range(10):
    i += j
print(i)
\end{lstlisting}
    \caption{``Unclear" variable naming}
    \label{fig:left}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.4\textwidth}
\begin{lstlisting}[language=Python]
total = 0
for curNum in range(10):
    total += curNum
print(total)
\end{lstlisting}
    \caption{Clear variable naming}
    \label{fig:right}
  \end{subfigure}
  \caption{2 equivalent programs in Python with different
  variable names. The intentions of the program on the right, b,
  becomes immediately clear.}
\end{figure}

The naming of variables and functions, to many beginners, is a surprisingly
important skill in programming. As stressed earlier, readability is vital
to the lifetime of a large software project. In Figure 4,
we demonstrate the clarity a good name can show in a trivial program.
In variable naming, the immediate advantage of using natural language is
obvious. Some more examples of good variable names \verb|isFinished|,
\verb|ready_list|, \verb|WinningStack|, etc.

Often non-English speakers will use foreign languages in their variable
names. In stack-exchange, a question and answer foreign for programmers,
some users share their experiences. Refer to Figure 5.

\begin{figure}[h]
    \label{fig:italian}
\centering
\caption[Caption for LOF]{
    A response from an Italian programmer. ``I'm Italian and always use English, for names and comments. But many other Italian programmers use Italian language, or more often a strange English-Italian mix (something like IsUtenteCopy)."
    (``Do people in non-English-Speaking countries code in English?")}
\begin{lstlisting}[language=C]
// Trovo la foto collegata al verbale
tblVerbali rsVerbale;
hr = rsVerbale.OpenByID(GetDBConn(), m_idVerbale);
if( FAILED(hr) )
    throw CErrorHR(hr);
hr = rsVerbale.MoveFirst();
if( S_OK != hr )
    throw CError(_T("Record del verbale non trovato."));
\end{lstlisting}
\end{figure}

Perhaps the most direct use of natural language in programming is the
practice of commentating code. Often, to bring clarity to his/her work,
a programmer will directly add ``comments" to the code. These ``comments"
are snippets of natural language that explain or take notes on
possibly confusing sections of code. An example is shown in Figure
6.

\begin{figure}[h]
    \label{fig:os_code}
\centering
\caption[Caption for LOF]{
    Code I have written for a class at UMich.
}
\begin{lstlisting}[language=C++]
void mutex::impl::unlock_body() {
    // catch misuse of unlock - throw when unlock an already unlocked lock
    if (holder_thread_id == -1 || holder_thread_id != cpu::self()->impl_ptr->active_thread_id)
    {
        // Exception handling:
        //  1. lock was never locked, but we call unlock
        //  2. lock is acquired by some other thread, but we call unlock
        // Throw exception: going back to user-level code
        guard.store(false);
        cpu::interrupt_enable();
        throw std::runtime_error("Attempted unlock without locking mutex or unlocking without owning lock!\n");
    }
    ...
\end{lstlisting}
\end{figure}

From the keywords carefully chosen in the design of programming languages,
to the choices programmers make when writing in these languages, the
act of programming is also an excercise in usage of natural language.
In fact, as English is so dominant in most popular programming languages,
many programmers believe that it is \textit{required} to know English
to learn how to program (Atwood).
Regardless, among programmers, there is no denying that any language is
critical to learning how to program and programming itself.
The greatest programs are the ones that not only bring algorithmic
insight, but also bring it with absolute clarity, carrying an
almost poetic beauty.

\newpage

\begin{center}
Notes
\end{center}

1. You may wonder how it is possible a finite set of simple instructions
can be used to construct useful programs. In fact, it was mathematically proven
by computer scientist Alan Turing that any program that can be written on a computer, can be written using
a simple \textit{Turing machine} with (technically) three instructions, move,
read, and write (Turing).

3. In practice, computers will read in binary format, a format of representing
numbers using only two symbols, 1 and 0.

4. Although assembly languages are difficult, they are powerful in their
precision and flexibility. Directly writing in assembly languages
still find use today in applications where performance is critical. Though,
as computer performance has increased, usage of assembly has equivalently
decreased (Hyde).

5. All of the examples of programming language shown take inspiration
from English. However, it is not the case that all programming languages use English.
The language ALGOL 68, had a standard document that allowed the
internalization of the language, allowing it translated into Russian,
German, French, Bulgarian, and then later Japanese (Lindsey).

6. Another point to make is that many natural languages such
as english will merge the meanings
of ``or" and ``exclusive or" into one meaning. ``Are pigs falling from
the sky, or am I crazy? - \textbf{No}! You're crazy \textit{and} pigs are falling
from the sky!" However, restricting to non-exclusive or, this dialogue should
be changed to ``Are pigs falling from
the sky, or am I crazy? - \textbf{Yes}! You're crazy \textit{and} pigs are falling
from the sky!"

\setlength{\parindent}{0.5in}


%%%%Works cited
\begin{workscited}

\bibent
Atwood, Jeff. “Coding Horror.” The Ugly American Programmer, blog.codinghorror.com/the-ugly-american-programmer/. 

\bibent
``Do people in non-English-Speaking countries code in English?" Programming languages - Do people in non-English-Speaking countries code in English? - Software Engineering Stack Exchange, softwareengineering.stackexchange.com/questions/1483/do-people-in-non-english-speaking-countries-code-in-english.


\bibent
Hyde, Randall. The art of assembly language. No Starch Press, 2010.

\bibent
Lindsey, Charles H. "A history of Algol 68." History of programming languages---II. ACM, 1996.

\bibent
Pearce, James. "9.9 million lines of code and still moving fast - Facebook open source ...." https://code.facebook.com/posts/292625127566143/9-9-million-lines-of-code-and-still-moving-fast-facebook-open-source-in-2014/. Accessed 17 Dec. 2017.

\bibent
"static". Dictionary.com Unabridged. Random House, Inc. 18 Dec. 2017. <Dictionary.com http://www.dictionary.com/browse/static>.

\bibent
Stroustrup, Bjarne. The C++ programming language. Pearson Education India, 2000.

\bibent
Turing, Alan M. "Computing machinery and intelligence." Mind 59.236 (1950): 433-460.

\bibent
Veres, Sandor M., and J. Patrik Adolfsson. "A natural language programming solution for executable papers." \textit{Procedia Computer Science} 4 (2011): 678-687.

\end{workscited}

\end{flushleft}
\end{document}
\}
